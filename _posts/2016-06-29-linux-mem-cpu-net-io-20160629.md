---
layout: post
title: Linux按照CPU、内存、磁盘IO、网络性能监测【转载】
categories: 好资源之常见问题解决 好资源之开发小纸条 软件质量之性能 项目管理之测试 好资源之开发神器
tags: linux CPU 内存 磁盘 IO 网络
---

#引言

转载地址[Linux按照CPU、内存、磁盘IO、网络性能监测 ](http://my.oschina.net/chape/blog/159640)

系统优化是一项复杂、繁琐、长期的工作，优化前需要监测、采集、测试、评估，优化后也需要测试、采集、评估、监测，而且是一个长期和持续的过程，不是说现在又花了、测试了，以后就可以一劳永逸，而不是说书本上的优化就适合眼下正在运行的系统，不同的系统、不同的硬件、不用的应用优化的重点也不同、优化的方法也不同、优化的参数也不同。

性能监测是系统优化过程中重要的一环，如果没有监测、不清楚性能瓶颈在哪里，怎么优化呢？所以找到性能瓶颈是性能监测的目的，也是系统优化的关键。

系统由若干子系统构成，通常修改一个子系统有可能影响到另外一个子系统，甚至会导致整个系统不稳定、崩溃。

所以说优化、监测、测试通常是连在一起的，而且是一个循环而且长期的过程，通常监测的子系统有以下这些：

* CPU
* Memory
* IO
* Network

这些子系统互相依赖，了解这些子系统的特性，监测这些子系统的系能参数以及及时发现可能会出现的瓶颈对系统优化很有帮助

###应用类型

不同的系统用途也不同，要找到性能瓶颈需要知道系统跑的是什么应用、有些什么特点，比如web server对系统的要求肯定和file server不一样，所以分清不同系统的应用类型很重要。

通常应用可以分为两种类型：

**IO相关**

* IO相关的应用通常用来出来大量的数据，需要大量内存和存储，频繁IO操作读写数据
* 而对CPU的要求则较少，大部分时间CPU都在等待硬盘，比如，数据库服务器、文件服务器等

**CPU相关**

* CPU相关的应用需要使用大量CPU
* 比如高并发的web/mail服务器、图像/视频处理、科学计算等都可视作CPU相关的应用

###监测工具

我们只需要简单的工具就可以对Linux的性能进行监控，以下常用的工具：

|     工具    |      简介                         | 
|---------- --|-----------------------------------|     
|  top        |  查看进程活动状态以及一些系统状况 |
|  vmstat     |  查看系统状态、硬件和系统信息等   |
|  iostat     |  查看CPU负载、硬盘状况            |
|  sar        |  综合工具，查看系统状况           |
|  mpstat     |  查看多处理器状况                 |
|  netstat    |  查看网络状况                     |
|  iptraf     |  实时网络状态监测                 |
|  tcpdump    |  抓取网络数据包，详细分析         |
|  tcptrace   |  网络包分析工具                   |
|  netperf    |  网络带宽工具                     |
|  dstat      |  综合了vmstat、iostat、ifstat、netstat等多个信息  |

本系列将按照CPU、内存、磁盘IO、网络这几个方面分别介绍

#Linux性能监测：CPU篇

CPU的占用主要取决于什么样的资源在CPU上面运行，比如拷贝一个文件通常占用较少的CPU，因为大部分工作是由DMA（Direct Memory Access）完成，只是在完成拷贝以后给一个中断让CPU知道拷贝已经完成；科学计算通常占用较多的CPU，大部分计算工作都需要在CPU上完成，内存、硬盘等子系统只是做暂时的数据存储工作。

要想监测和理解CPU的性能需要知道一些的操作系统基本知识，比如：中断、进程调度、进程上下文切换、可运行队列等。

用一个例子来简单介绍一下这些概念和他们的关系，CPU很无辜，是个任劳任怨的打工仔，每时每刻都有工作在做（进程、线程）并且自己有一张工作清单（可运行队列），由老板（进程调度）来决定他该干什么，他需要和老板沟通以便得到老板的想法并及时调整自己的工作（上下文切换），部分工作做完以后还需要及时向老板汇报（中断），所以打工仔（CPU）除了做自己该做的工作之外，还有大量时间和精力花在沟通和汇报上。

CPU也是一种硬件资源，和任何其他设备一样也需要驱动和管理程序才能使用，我们可以把内核的进程调度看作是CPU的管理程序，用来管理和分配CPU资源，合理安排进程抢占CPU，并决定哪个进程该使用CPU、哪个进程该等待。

操作系统内核里的进程调度主要用来调度两类资源：进程（或线程）和中断，进程调度给不同的资源分配了不同的优先级，**优先级最高的是硬件中断，其次是内核（系统）进程，最后是用户进程**。

每个CPU都维护这一个可运行队列，用来存放那些可运行的线程。线程要么在睡眠状态（blocked正在等待IO）、要么在可运行状态，如果CPU当前负载太高而新的请求不断，就会出现进程调度暂时应付不过来的情况，这个时候就不得不把线程暂时放到可运行队列中。

本文是讨论的性能监测，上面淡了一堆都没提到性能，那么这些概念和性能监测有什么关系呢？关系重大！如果你是老板，你如何检查打工仔的效率（性能）呢？我们一般会通过以下这些信息来判断打工仔是否偷懒：

* 打工仔接受和完成多少任务并向老板汇报了（中断）
* 打工仔和老板沟通、写上每项工作的工作进度（上下文切换）
* 打工仔的工作列表是不是都有排满（可运行队列）
* 打工仔工作效率如何，是不是在偷懒（CPU利用率）

现在把打工仔换成CPU，我们可以通过查看这些重要参数：**中断**、**上下文切换**、**可运行队列**、**CPU利用率**来检测CPU的性能。

###底线

Linux性能监测：介绍提到了性能监测需要知道底线，那么监测CPU性能的底线是什么呢？

通常我们期望我们的系统能达到以下目标：

* **CPU利用率**，如果CPU用100%的利用率，那么应该达到这样一个平衡：65%-70% User Time，30%-35% System Time，0%-5% Idle Time
* **上下文切换**，上下文切换应该和CPU利用率联系起来看，如果能保持上面的CPU利用率平衡，大量的上下文切换是可以接受的
* **可运行队列**，每个可运行队列不应该由超过1-3个线程（每处理器），比如：双处理器系统的可运行队列里不应该超过6个线程

###vmstat命令

vmstat是个查看系统整体性能的小工具，小巧，即使在很heavy的情况下也允许良好，并且可以用时间间隔采集得到连续的性能数据。

参数介绍：

* r，可运行队列的线程数，这些线程都是可运行状态，只不过CPU暂时不可用
* b，被blocked的进程数，正在等待IO请求
* in，被处理过的中断数
* cs，系统上正在做上下文切换的数目
* us，用户占用CPU的百分比
* sys，内核和中断占用CPU的百分比
* wa，所有可运行的线程被blocked以后都在等待IO，这时候CPU空闲的百分比
* id，CPU完全空闲的百分比

举两个现实中的例子来分析一下

[!img](01.png)

从上面的数据可以看出几点：

1. interrupts(in)非常高，context switch(cs)比较低，说明这个CPU一直在不停的请求资源
2. user time(us)一直保持在80%以上，而且上下文切换较低(cs)，说明某个进程可能一直霸占着CPU
* run queue(r)刚好在4个

[!img](02.png)

从上面的数据可以看出几点：

1. context switch(cs)比interrupts(in)要高的多，说明内核不得不来回切换进程
2. 进一步观察发现system time(sy)很高而user time(us)很低，而且加上高频度的上下文切换(cs)，说明正在运行的应用程序调用了大量的系统调用
3. run queue(r)在14个线程以上，按照这个而是机器的硬件配置（4核），应该保持在12以内

###mpstat命令

mpstat和vmstat类似，不同的是mpstat可以输出多个处理器的数据，下面的输出显示CPU1和CPU2基本上没有派上用场，系统有足够的能力处理更多的任务

[!img](03.png)

###ps命令

如何查看某个程序、进程占用了多少CPU资源呢？下面是FireFox在一台Sunray服务器上的运行情况，当前只有2个用户在使用Firefox

[!img](04.png)


#Linux性能监测：内存篇

这里讲到的“内存”包括**物理内存**和**虚拟内存**。虚拟内存（Virtual Memory）把计算机的内存空间扩展到硬盘，物理内存（RAM）和硬盘的一部分空间（SWAP）组合在一起作为虚拟内存为计算机提供了一个连续的虚拟内存空间，好处是我们拥有的内存“变多了”，可以运行更多、更大的程序，坏处是把部分硬盘当内存用，整体性能受到影响，硬盘读写速度要比内存慢几个数量级，并且RAM和SWAP之间的交换增加了系统的负担。

在操作系统里，虚拟内存被分为页，在x86系统上每个页大小是4KB。Linux内核读写虚拟内存是以“页”为单位操作的，把内存转移到硬盘交换空间（SWAP）和从交换空间读取内存的时候都是按页来读写的。

内存和SWAP的这种交互过程称为页面交换（Paging），值得注意的是paging和swapping是两个完全不同的概念，国内很多参考书把这两个概念混为一谈，swapping也翻译为交换，在操作系统里是指把某程序完全交换到硬盘以腾出内存给新程序使用，和paging只交换程序的部分（页面）是两个不同的概念。春吹的swapping在现代操作系统中已经很难看到了，因为把整个程序交换到硬盘的办法既耗时又费力而且没必要，现代操作系统基本都是paging或者paging/swapping混合，swapping最初是在Unix system V上实现的。

虚拟内存管理是Linux内核里面最复杂的部分，要弄懂这部分内容可能需要一本书的讲解。这里只介绍和性能监测有关的两个内核进程：kswapd和pdflush。

**kswapd daemon**用来检查pages_high和pages_low，如果可用内存少于pages_low，kswapd就开始扫描并试图释放32个页面，并且重复扫描释放的过程知道可用内存大于pages_high为止。扫描的时候检查3件事：

* 如果页面没有修改，把页放到可用内存列表里
* 如果页面被文件系统修改，把页面内容写到磁盘上
* 如果页面被修改了，但不是被文件系统修改的，把页面写到交换空间

**pdflush daemon**用来同步文件相关的内存页面，把内存页面及时同步到硬盘上。比如打开一个文件，文件被导入到内存里，对文件修改并保存后，内核并不马上保存文件到硬盘，由pdfush决定什么时候把相应页面写到硬盘，这由一个内核参数vm.dirty_background_ratio来控制，比如下面的参数显示脏页面（dirty pages）达到所有内存页面10%的时候开始写入硬盘。

[!img](05.png)

###vmstat命令

继续vmstat一些参数的介绍，上一篇Linux性能监测：CPU介绍了vmstat的部分参数，这里介绍另外一部分。以下数据来自一个256MB RAM，512MB SWAP的Xen VPS：

[!img](06.png)

* swpd，已使用的SWAP控件大小，KB为单位
* free，可用的物理内存大小，KB为单位
* buff，物理内存用来缓存读写操作的buffer大小，KB为单位
* cache，物理内存用来缓存进程地址空间的cache大小，KB为单位
* si，数据从SWAP读取到RAM（swap in）的大小，KB为单位
* so，数据从RAM写到SWAP（swap in）的大小，KB为单位
* bi，磁盘块从文件系统或SWAP读取到RAM（blocks in）的大小，block为单位
* bo，磁盘块从RAM写到文件系统或SWAP（blocks out）的大小，block为单位

上面是一个频繁读写交换区的例子，可以观察到以下几点：

* 物理可用内存free基本没有显著变化，swapd逐步增加，说明最小可用的内存始终保持在256MB X 10% = 2.56MB左右，当
