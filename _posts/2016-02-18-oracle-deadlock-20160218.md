---
layout: post
title: Oracle数据表死锁的一个简单排查方法
categories: 数据库之oracle 数据库之sql 深入学习之数据库原理 
tags: oracle 数据库 死锁 sql ora-00060
---

##报错以及错误解释

程序中涉及到使用SQL操作数据库，但是程序运行报错：ORA-00060: deadlock detected while waiting for resource

##一个简单的排查和解决方法

###制造死锁

执行下面的SQL，查看被锁的表：

```
select object_name, machine, s.sid, s.serial#
  from v$locked_object l, dba_objects o, v$session s
 where l.object_id = o.object_id
   and l.session_id = s.sid
```

执行下面的SQL可以强制解锁

```
alter system kill session '277,1817'
--其中277对应上句SQL查出来的sid字段， 1817对应serial字段具体的值
```

具体的操作可以看下面的实例，更加直观的理解死锁，并且去解决死锁

##通过一个实例操作来更深入的理解

参考自[一个常见的ORA-00060死锁现象](http://www.linuxidc.com/Linux/2012-07/66890.htm)

在Oracle数据库中如果出现死锁现象，数据库就会报ORA-00060的错误代码，这种死锁现象通常都是应用逻辑设计出错导致的异常，和数据库本身的设计无关，现在通过实验模拟一个死锁现象：

创建一个用于测试的数据表，并且添加几条测试数据：

```
create table practice(uno varchar(8), uname varchar(20));

insert into practice values ('198', 'xm198-1');
insert into practice values ('198', 'xm198-2');
insert into practice values ('200', 'xm200-1');
insert into practice values ('200', 'xm200-2');
commit;
```

**打开一个PLSQL**，在PLSQL中打开两个Command Window执行下列更新顺序（下面的会话就是指Command Window）

会话1：执行对uno为198的字段更新，注意不执行commit;

```
SQL> update practice set uname = 'cj' where uno = '198';
2 rows updated
```

会话2：执行对uno为200的字段更新，注意不执行commit;

```
SQL> update practice set uname = 'hh' where uno = '200';
2 rows updated
```

会话1：再执行对uno为200的字段更新，注意不执行commit;，此时语句已经hang住（也就是卡住了，不像上面两次的执行会输出2 rows updated这样的结果信息），需要等到会话2发出commit或者rollback动作

```
SQL> update practice set uname = 'cj' where uno = '200';   ---会话1在这里hang住了
```

会话2：一旦执行下面的更新，会话2也会hang住，回到会话1就会发现会话1报错

```
update practice set uname = 'sdf' where uno = '198';
```

回到会话1，可以看到会话1报错信息

```
SQL> update practice set uname = 'cj' where uno = '200';
update practice set uname = 'cj' where uno = '200'
ORA-00060: 等待资源时检测到死锁
```

查询alert日志发现报错：ORA-00060: Deadlock detected. More info in file /u01/app/oracle/admin/prod/udump/prod_ora_4273.trc.

###补充说明：

如果在会话2中第二次不执行上面的更新SQL，而是执行commit;或者rollback;那么会话1就不会报错

比如会话2执行

```
SQL> rollback;
Rollback complete
```

回去检查会话1，发现之前hang住的地方，现在已经解决了

```
SQL> update practice set uname = 'cj' where uno = '200';    --之前是hang在这里没有办法更新的，现在因为会话2执行rollback，所以会话1从hang住恢复过来了
2 rows updated
```

###强制解锁

注意这里需要使用系统用户，因为一般用户是没有权限的，我是**重新打开一个PLSQL**，使用SYSTEM用户登陆进行下面的操作的，再在新的PLSQL中打开一个Command Window

在新的PLSQL的会话中，通过dba_blockers表中的HOLDING_SESSION字段可以查询到hang住会话的ID：

```
SQL> select * from dba_blockers;
HOLDING_SESSION
---------------
             76
```

使用v$session视图获取hang住会话的sid和serial#

```
SQL> select sid,serial#,username from v$session where sid in (select blocking_session from v$session);
       SID    SERIAL# USERNAME
---------- ---------- ------------------------------
        76        271 TRADE
```

找到hang住的会话后，执行alter system命令kill掉相应的session就可以了：

```
SQL> alter system kill session '76,271' immediate;
System altered
```

###检查之前的会话来确认一下

执行后上面的强制解锁之后，返回前一个PLSQL，检查其中的两个会话，会话1中的会话会自动被kill掉

在会话1执行查询SQL，会发现报错：

```
SQL> select * from practice;
Warning: connection was lost and re-established
UNO      UNAME
-------- --------------------
198      xm198-1
198      xm198-2
200      xm200-1
200      xm200-2
```
 
会话2中执行查询发现会话2的更改生效。在会话2中执行下面查询SQL，没有报错，其实当前

```
SQL> select * from practice;
UNO      UNAME
-------- --------------------
198      sdf
198      sdf
200      hh
200      hh
```

但是再在当前的PLSQL打开一个Command Window（叫会话3），执行查询语句，发现结果和会话2不一致

```
SQL> select * from practice;
UNO      UNAME
-------- --------------------
198      xm198-1
198      xm198-2
200      xm200-1
200      xm200-2
```

回到会话2，发现还没有提交，所以在提交后，再执行查询看结果

```
SQL> commit;
Commit complete

SQL> select * from practice;
UNO      UNAME
-------- --------------------
198      sdf
198      sdf
200      hh
200      hh
```

然后再回到会话3，执行查询语句，发现现在和会话2一样了

```
SQL> select * from practice;
UNO      UNAME
-------- --------------------
198      sdf
198      sdf
200      hh
200      hh
```

实际上，当出现死锁的情况，Oracle也会在一段时间后解锁。这种情况会在alert日志中记载下列信息：ORA-00060: Deadlock detected. More info in file /u01/app/oracle/admin/ORCL/udump/orcl_ora_3173.trc.linux
