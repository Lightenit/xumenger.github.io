---
layout: post
title: delphi怎么在代码中生成dbf文件
categories: delphi之数据库 delphi之多线程 
tags: delphi dbf ado bde 多线程
---

这主要是自己在一次任务开发中，要求程序在运行的时候生成新的dbf文件来存储数据，所以在这方便就找到了一些使用的方法，也有一些注意事项

不过，做完这次开发也只是简单的知道怎么用一些API、遇到的一些问题要怎么解决，但是对于设计到的相关的数据库引擎、具体的深入的原因还是不够清楚的，这个也是接下来需要提升的地方

##使用BDE方式创建新的DBF

刚开始的时候，参考我们组内其他同事的程序，可以实现通过代码实现创建dbf文件，大概的代码是这样的

```
unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, DBTables, DB;

type
  TForm1 = class(TForm)
    btn1: TButton;
    procedure btn1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

  T2Array = array of array of string;

var
  Form1: TForm1;
  table: TTable;

implementation

{$R *.dfm}

procedure TForm1.btn1Click(Sender: TObject);
var
  i: Integer;
  ArrData: T2Array;
  field: TFieldDef;
begin
  table:= TTable.Create(nil);
  SetLength(ArrData,4,2);
  ArrData[0][0] := 'row1';
  ArrData[0][1] := '10';
  ArrData[1][0] := 'row2';
  ArrData[1][1] := '20';
  ArrData[2][0] := 'row3';
  ArrData[2][1] := '2';
  ArrData[3][0] := 'row4';
  ArrData[3][1] := '2';

  table.Close;
  table.Active:=false;
  table.Exclusive:=true;
  table.TableName:='.\test.DBF';
  table.TableType:=ttFOXPRO;

  table.FieldDefs.Clear;
  for i := Low(ArrData) to High(ArrData) do
  begin
    field:= table.FieldDefs.AddFieldDef;

   field.Name := ArrData[i][0];
   field.DataType := FTSTRING;
   field.Size := StrToInt(ArrData[i][1]);

  end;
  table.CreateTable;
end;

end.
```

这里只是一个简单的小demo创建dbf的例子，放到多线程环境下，在自己本地进行测试的时候（自己简单的封装了一个使用这种方式创建DBF文件的函数），每个线程（主线程和子线程）都可以正常创建DBF文件

但是等到将程序部署到客户实际的环境之后，出现问题了，在创建DBF文件的时候会报错：创建DBF失败：An error occered while initializing Borland Database Engine (error $2108)

经过上网查询，确定大概的问题是因为客户那里没有安装BDE（Borland Database Engine）数据库引擎。然后尝试在其中的一个客户那里安装了BDE数据库引擎，然后在运行这个多线程程序，创建DBF是OK的

##暂时的应对方案--拷贝DBF文件

在一个客户那里将问题解决了，但是不能要求所有的用户为了使用我的这个程序，都要现在立即在额外安装BDE数据库引擎

不过现场情况紧急，需要当天现场测试能通过，所以就需要想一个暂时的解决方法，于是就想到，我这边先将需要的DBF文件创建好，然后修改程序逻辑，将创建DBF的方法改成拷贝DBF文件，然后将需要的空的DBF文件的模板提供到现场，要求用户放到指定目录下

这样通过这种稍微复杂点的配置方法，避免每个客户再去安装BDE数据库引擎，然后将当天的现场测试通过了

##还是不好--还是得在程序中创建DBF

这样的方式还是不够好，刚开始的时候还要麻烦用户去将DBF模板文件配置好，这样太费事，所以还得想办法通过代码生成DBF文件

于是就去请教公司里对Delphi比较熟悉的老员工，于是提供了一个不需要用户安装什么其他的数据库引擎就能创建DBF文件的方法，代码实例如下

```
unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, DB, ADODB;

type
  TForm1 = class(TForm)
    btn1: TButton;
    procedure btn1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.btn1Click(Sender: TObject);
var
  con1: TADOConnection;
  qry1: TADOQuery;
  SourceDress, sConnectionString, sTableName, Sqltext: string;
begin
  con1:= TADOConnection.Create(nil);
  qry1:= TADOQuery.Create(nil);
  SourceDress := ExtractFilePath(Application.ExeName);
  sConnectionString:='Provider=Microsoft.Jet.OLEDB.4.0;Data Source='+SourceDress+';Extended Properties=dBase 5.0;Persist Security Info=False;';
  con1.ConnectionString:= sConnectionString;
  con1.Open;

  //创建DBF文件
  sTableName := 'tbTest' + FormatDateTime('yyyymmddhhmmss',Now);
  Sqltext:='create table '+ sTableName + '.dbf' +'(row1 char(6),row2 char(8),row3 char(4))';
  qry1.Connection:= con1;
  qry1.Close;
  qry1.SQL.Clear;
  qry1.SQL.Add(SqlText);
  qry1.ExecSQL;

  //在里面放入一条数据
  Sqltext := 'insert into ' + sTableName + '(row1,row2,row3)values(' + QuotedStr('123456') + ',' + QuotedStr('12345678') + ',' + QuotedStr('yy') + ')';
  qry1.Close;
  qry1.SQL.Clear;
  qry1.SQL.Add(Sqltext);
  qry1.ExecSQL;

  qry1.Free;
  con1.Free;
end;

end.
```

这里是一个小的例子，在我的项目中（多线程的），需要将这个方法封装成一个创建DBF的函数

##还是有问题--多线程环境和单线程有很大的区别

将使用ADO方式创建DBF的方式封装成一个函数，放到我的程序中需要创建DBF的地方，以为这样就OK了

但是在改完程序之后，简单的进行了一下测试，果然出现问题了（墨菲又来了）

**问题1**

在程序运行的时候，会弹出框，要求你填写登录数据库的用户名和密码（这个在自己之前简单模拟创建DBF的单线程程序中是没有的）

这个显然是不允许的

上网查到了方法：将其中的ADOConnection对象的LoginPrompt属性设置为False就可以了（暂时不清楚具体的原因）

**问题2**

创建DBF的时候还是会报错：不正常地定义参数对象。提供了不一致或不完整的信息

为什么在之前的单线程程序中没有问题，但是现在在多线程环境下有问题。这时候老大给了一个提示：这个并不是因为是不是多线程环境，而是因为创建DBF的函数是不是在主线程中执行

简单测试一下，发现在主线程中调用这种创建DBF的方法是OK的，但是在子线程中就会报错，想到去加锁，但是好像还是不行

再去查了一下，解决方法是：将其中的ADOQuery对象的ParamCheck属性设置为False就可以避免在子线程中创建DBF报错了（具体的底层的原理目前还是不清楚）

**问题3**

这种方法创建的DBF文件的名字的长度不能超过8个字节，比如你要创建一个DBF，命名是123456789.dbf，最后创建出来的DBF的名字可能是12345678.bdf

所以这点要注意，如果你直接在使用ADO创建DBF的方式创建时命名，那么接下来想要打开DBF文件的时候，需要注意文件名可能会缩短。暂时的解决方法：1、创建时就不使用长名字；2、先创建一个短名字的文件，然后通过移动函数给文件重命名

还是有几种情况，需要说明一下

* 让朋友帮忙在一个没有安装任何开发工具的计算机环境上执行单线程使用ADO方式创建DBF文件的程序，创建的文件名限制在8位以内
* 在自己装有各种开发工具的计算机环境上执行单线程使用ADO方式创建DBF文件的程序，创建的文件名可以超过8位
* 在多线程环境的子线程中使用ADO方式创建DBF，由被限制在8位以内
* 多线程环境的主线程中使用ADO方式创建DBF，创建的文件名可以超过8位

**所以又有一个经验收获，多线程开发时候首先的难点在于多线程控制，比如控制多线程对于某个共享资源的使用、控制多线程的启动顺序、控制多线程的结束顺序，另外就是很多事情主线程可以做但是子线程是没办法做的**

只能说，坑真多，不知道还有没有其他的意外情况

##使用ADO方式可以在多线程下创建DBF，但是还有问题

使用ADO方式可以在多线程环境下（主要是子线程）创建DBF文件，文件名限制的问题可以暂时通过不命名超过8位的名字的方式来解决

但是问题又出现了，因为自己封装的函数在每次创建DBF文件的时候，需要创建ADOConnection、ADOQuery对象，导致程序因为创建DBF而速度特别慢

于是在针对程序需要创建DBF文件的这个要求进行优化

* 程序在启动初始化的时候直接在某个目录下创建好需要的DBF文件（一个空的模板）
* 然后在程序运行中需要创建DBF的地方不再创建DBF文件，而是拷贝在初始化是已经创建好的模板DBF文件

经过测试，直接拷贝空的DBF文件比每次都在创建DBF文件快得多，另外就是可以在拷贝DBF文件的时候给DBF文件命名，而且命名不会再限制在8为以内

##但是依然不好
