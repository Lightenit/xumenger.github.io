---
layout: post
title: Delphi对象内存模型：Delphi继承语法下的对象内存
categories: delphi之dll c/c++之dll c/c++之指针与内存 delphi之指针与内存 delphi之面向对象 c/c++之面向对象 软件质量之内存管理 深入学习之内存管理
tags: c delphi dll 导出函数 函数指针 字符串 面向对象 多态 Delphi对象内存模型 VMT
---

Delphi的面向对象语法中，当创建一个类的实例后，编译器会在该对象的内存空间的首4个地址安插一个指针，该指针所指向的地址称为VMT（Virtual Method Table，虚方法表），这个表中存放了该类的所有虚方法的入口地址。在Delphi中，所有类实例都会有这么一个指向VMT的指针。如果没有在类中声明虚方法，则该指针值为nil

>创建一个类，然后直接使用指针访问的形式进行验证！

##含有虚方法的类内存模型

假如有一个父类TBase以及它的一个派生类TDerived

```
TBase = class
protected
	s: string;
public
	procedure proc1(); virtual; abstract;
	procedure proc2(): virtual; abstract;
	function func1(): string; virtual;
end;

TDerived = class(TBase)
public
	constructor Create();
	destructor Destroy(); override;
	procedure proc1(); override;
	procedure proc2(); override;
end;
```

用TBase类型指针创建一个TDerived对象实例

```
var
	base: TBase;
begin
	base := TDerived.Create();
end;
```

这时候base指针指向的对象内存模型如下

>使用visio画图展示

没有被派生类覆盖的方法，编译器会基类的该方法的实现入口地址填入派生类的VMT中。比如上面的例子，TDerived类覆盖了基类TBase的proc1()和proc2()，因此在TDerived的VMT中，proc1()和proc2()被确定位TDerived自己所实现的方法入口地址。而由于TDerived没有覆盖父类的func1()方法，所以在TDerived的VMT中还是填入TBase.func()的入口地址

继续上面的代码，所以当调用base.proc1()的时候对应调用子类TDerived实现的proc1()方法，而当调用base.func1()的时候则对应调用的父类TBase实现的func1()方法

这部分的解释总体和C++对象内存模型一致，可以对比《C++对象内存模型》系列以更深入的了解


