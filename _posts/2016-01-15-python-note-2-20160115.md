---
layout: post
title: Python学习笔记之高级特性
categories: python之基础 
tags: python python2 python3
---

掌握了Python的数据类型、语句和函数，基本上就可以编写出很多有用的程序了。（下面的程序中没加特殊说明的，就表示对Python2.7和Python3都支持）

比如构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：

```
L = []
n = 1
while n <= 99:
  l.append(n)
  n = n + 2
```

取list的前一半的元素，也可以通过循环实现。

但是在Python中，**代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好**。用任何的语言编程都应该是这样。

基于这一思想，我们来介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。

##切片

```
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
L1 = L[:3]    #['Michael', 'Sarah', 'Tracy']
L2 = L[1:3]    #['Sarah', 'Tracy']
L3 = L[-2:]    #['Bob', 'Jack']
L4 = L[-2:-1]    #['Bob']
#list的第一个元素的索引是0，倒数第一个元素的索引是-1

LL=list(range(100))    #[1,2,3,...,99]
LL1=L[-10:]    #[90,91,...,99] 后10个数
LL2=L[10:20]    #[10,11,12,...,19] 前11-20个数
LL3=L[:10:2]    #[0,2,4,6,8] 前10个数，每两个取一个
LL4=L[::5]    #[0,5,10,...,90,95] 所有数，每5个取一个
LL5=L[:]    #甚至什么都不写，只写[:]就可以原样复制一个list
```

tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。

```
T=(0,1,2,3,4,5)
T1=T[:3]
```

字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：

```
T='ABCDEFG'
T1=T[:3]    #'ABC'
T2=T[::2]    #'ACEG'
```

在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。

有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。

##迭代

Python的for循环抽象程度要高于Java的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。

list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代。

```
d = {'a':1, 'b':2, 'c':3}
for key in d:
  print(key)
#输出a c b
```

为什么输出的结果是a c b，不是a b c，因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。关于dict的存储的知识，请参见[对应的dict教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143167793538255adf33371774853a0ef943280573f4d000)。

默认情况下，dict迭代的是key。如果要迭代value，可以用`for value in d.values()`，如果要同时迭代key和value，可以用`for k, v in d.items()`。

由于字符串也是可迭代对象，所以可以用于for循环。

```
for ch in 'ABCD':
    print ch
```

所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：

```
from collections import Iterable
isinstance('abc', Iterable) # str是否可迭代  True
isinstance([1,2,3], Iterable) # list是否可迭代  True
isinstance(123, Iterable) # 整数是否可迭代  False
```

最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

```
for i, value in enumerate(['A', 'B', 'C']):
  print(i, value)

#Python2.7输出
(0, 'A')
(1, 'B')
(2, 'C')

#Python3输出
0 A
1 B
2 C
```

上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：

```
for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)
```

#列表生成式

```
L=list(range(1,11))    #生成[1,2,3,4,5,6,7,8,9,10]
L1=[x*x for x in range(1,11)]  #生成[1*1,2*2,...,10*10]
```

写列表生成式时，把要生成的元素比如x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。

for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：

```
L = [x*x for x in range(1, 11) if x % 2 == 0]
#[4, 16, 36, 64, 100]
```

还可以使用两层循环，可以生成全排列：

```
L= [m + n for m in 'ABC' for n in 'XYZ']
#['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```

三层和三层以上的循环就很少用到了。

例程，列出当前目录下的所有文件和目录名

```
import os
L = [d for d in os.listdir('.')]  #os.listdir可以列出文件和目录
print(L)
#测试在我的一个目录下，Python2.7和Python3都输出
['index.py', 'for.py', 'list.py', 'fact.py', 'defe.py']
```

for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：

```
d = {'x': 'A', 'y': 'B', 'z': 'C' }
for k, v in d.items():
    print(k, '=', v)
```

因此，列表生成式也可以使用两个变量来生成list：

```
d = {'x': 'A', 'y': 'B', 'z': 'C' }
L= [k + '=' + v for k, v in d.items()]
#输出
['y=B', 'x=A', 'z=C']
```

把一个list中所有的字符串变成小写：

```
L = ['Hello', 'World', 'IBM', 'Apple']
L1= [s.lower() for s in L]
```

##生成器

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

