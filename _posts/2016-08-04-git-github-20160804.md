---
layout: post
title: 同步管理本地git仓库和github仓库上的分支
categories: 项目管理之版本控制 好资源之开发神器 好资源之开发小纸条
tags: github git 版本控制
---

##参考文章

* [《使用git和github管理自己的项目---基础操作学习》](http://www.xumenger.com/github-git-learn/)
* [《使用git和github管理自己的项目---真实开发环境的策略》](http://www.xumenger.com/github-git-use/)
* [《使用git和github进行协同开发流程》](http://segmentfault.com/a/1190000002413519)

##分支管理策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

* 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活
* 那在哪里干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的
* 到某个时候，比如2.0版本发布时，再把dev分支合并到master上，在master分支发新版本
* 你和你的小伙伴每个人都在dev分支上干活，每个人都有自己的分支，时不时往dev分支上合并就可以了

![github-1.png](../media/image/2016-08-04/github-1.png)

##bug分支

软件开发中，bug就像是家常便饭一样。比如从master分支上发布的版本有了bug，那么就需要赶紧修复，在Git中，由于分支是如此的强大，所以每个bug都可以通过一个从master上拉出来一个新的临时分支来修复bug，修复后，合并分支，然后将临时分支删除

* 当你接到一个修复代号为101的bug的任务时
  * 很自然的，你想创建一个分支`issue-101`来修复它
  * 但是，等等，当前正在 dev上进行的工作还没有提交到master上：
* `git status` 查看状态
* 并不是你不想提交，而是工作只进行到一半，还没法提交
  * 预计完成还需1天时间
  * 但是，必须在两个小时内修复该bug，怎么办？
* 在dev分支执行`git stash`命令
  * 可以把当前分支的工作现场“储藏”起来
  * 等以后恢复现场后继续工作
* 在dev分支执行`git status`命令查看工作区
  * 是干净的（除非有没有被Git管理的文件）
  * 因此可以放心的创建分支来修复bug了
* `git checkout master` 从dev分支切换回master
* `git checkout -b issue-101` 假定需要在master分支上修复，就从`master`创建临时分支
* 假设现在修复好了bug，本例中，就假如在readme.txt文件中做了修改
* `git add readme.txt` 
* `git commit -m "fic bug 101"` 修改之后提交
* `git checkout master` 从issue-101切换回master
* `git merge --no-ff -m "merged bug fix 101" issue-101` 
  * 合并分支选择不适用Fast forward模式，然后添加必要的描述信息
* `git branch -d issue-101` 删除issue-101这个临时bug修复分支
* 太棒了，bug搞定了，现在可以回到`dev`分支干活了
* `git checkout dev` 切换回dev分支
* `git status` 可以看出工作区是干净的，那么刚才的工作现场存在哪里呢？
* `git stash list` 看到工作现场还在，Git把stash内容存在某个地方了，但需要恢复一下
* 方法一：`git stash apply`
  * 但恢复后，stash内容并不删除
  * 你需要使用`git stash drop`来删除
* 方法二：`git stash pop`，恢复的同时也把stas内容删除了
* `git stash list` 再用git stash list查看，就看不到任何stash内容了
* 你可以多次`stash`
  * 恢复时，先用`git stash list` 查看
  * 然后恢复指定的stash，使用命令：`git stash apply stash@{0}`

修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除。当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场

##Feature分支

软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支

* 假如现在，你终于接到了一个新任务：开发代号为Vulcan的新功能。于是开始准备工作
* `git checkout -b feature-vulcan` 在dev分支上创建并且换到feature-vulcan分支，用来开发新功能
* 假如现在经过一定的时间后，工作完成了
* `git add vulcan.py`
* `git status` 查看状态
* `git commit -m "add feature vulcan"` 提交
* `git checkout dev` 切换回dev分支
* 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除
  * 但是，就在此时，接到上级命令，因经费不足，新功能必须取消！
  * 虽然白干了，但是这个分支还是必须就地销毁，不要再合并了
* `git branch -d feature-vulcan` 销毁失败
  * Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改
  * 如果要强行删除，需要使用命令git branch -D feature-vulcan。
* `git branch -D feature-vulcan`


##同步本地和github上的分支

* 先在Github上通过网页创建一个仓库，假设名叫TestGit
* 参考[《使用git和github管理自己的项目---基础操作学习》](http://www.xumenger.com/github-git-learn/)，配置连接远程仓库Github
* 执行`git clone git@github.com:xumenger/TestGit.git`即可将其克隆到本地
  * 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了
  * 并且，远程仓库的默认名称是origin
* 新建的仓库都只有一个分支，即主分支master
* 创建一个新分支`git checkout -b dev`，同时已经从master切换到这个分支上了
* 在这个分支上可以编辑代码，比如修复了test.py上的一个bug
* `git diff test.py` 查看对test.py做了什么修改
* `git add test.py`
* `git commit -m "修复了bug"`，将其提交到dev分支
  * 可以去github网页上看这个修改已经同步到github上了
* `git push origin dev`，将本地 dev分支同步到远程仓库，也就是同步到 github
* `git checkout master`，切换到主分支
* `git merge --no-ff -m "merge with with no-ff" dev`
  * 将dev分支上的工作成果合并到master分支
  * 注意--no-ff参数表示禁用Fast forward
  * 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去
  * 直接用`git merge dev`也可以合并，但这种模式下，删除分支后，会丢掉分支信息。
* `git push origin master`，将本地主分支同步到远程github上
  * 可以去github网页上看这个修改已经同步到github上了
* 注意直接通过将其他分支合并上的修改合并到主分支上之后就可以同步到远程github
  * 不需要再在主分支上执行：git add ...、git commit -m "..."了
* 然后可以执行`git branch -d dev`，删除临时分支，当然也可以不执行该命令，继续保留该分支
* `git branch`可以查看当前的所有分支